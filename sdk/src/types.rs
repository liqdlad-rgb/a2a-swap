//! Parameter and result types for every SDK operation.

use serde::{Deserialize, Serialize};
use solana_sdk::pubkey::Pubkey;

// ─── Input parameters ─────────────────────────────────────────────────────────

/// Parameters for [`A2ASwapClient::create_pool`].
#[derive(Debug, Clone)]
pub struct CreatePoolParams {
    /// First token mint (defines "token A" for the pool PDA seed).
    pub mint_a: Pubkey,
    /// Second token mint (defines "token B" for the pool PDA seed).
    pub mint_b: Pubkey,
    /// LP fee rate in basis points. Range: 1–100 (0.01%–1.00%). Typical: 30 (0.30%).
    pub fee_rate_bps: u16,
}

/// Parameters for [`A2ASwapClient::provide_liquidity`].
#[derive(Debug, Clone)]
pub struct ProvideParams {
    /// First token mint — must match the pool's `token_a_mint`.
    pub mint_a: Pubkey,
    /// Second token mint — must match the pool's `token_b_mint`.
    pub mint_b: Pubkey,
    /// Amount of token A to deposit (atomic units: lamports for SOL, μUSDC for USDC, …).
    pub amount_a: u64,
    /// Amount of token B to deposit (atomic units).
    ///
    /// - `None` when the pool already has liquidity: the SDK fetches live reserves
    ///   and computes `amount_b = amount_a × reserve_b / reserve_a`.
    /// - `Some(n)` when the pool is empty (first deposit) — this sets the initial price.
    ///   Also accepted when you want to override the proportional amount.
    pub amount_b: Option<u64>,
    /// Re-invest accrued fees into LP shares instead of sending them to your wallet.
    pub auto_compound: bool,
    /// Minimum combined fee balance (fees_a + fees_b, atomic units) before an
    /// auto-compound fires. `0` means "compound every time fees are claimed".
    pub compound_threshold: u64,
    /// Minimum LP shares to accept. `0` means no slippage guard on LP minting.
    pub min_lp: u64,
}

/// Parameters for [`A2ASwapClient::convert`].
#[derive(Debug, Clone)]
pub struct SwapParams {
    /// Mint of the token you are selling.
    pub mint_in: Pubkey,
    /// Mint of the token you want to receive.
    pub mint_out: Pubkey,
    /// Amount of the input token to sell (atomic units).
    pub amount_in: u64,
    /// Maximum acceptable slippage in basis points (e.g. `50` = 0.5%).
    /// Applied to the pre-flight simulation estimate:
    /// `min_amount_out = estimated_out × (1 − max_slippage_bps / 10_000)`.
    /// Set to `0` to disable the slippage guard.
    pub max_slippage_bps: u16,
}

/// Parameters for [`A2ASwapClient::simulate`].
#[derive(Debug, Clone)]
pub struct SimulateParams {
    /// Mint of the token you would sell.
    pub mint_in: Pubkey,
    /// Mint of the token you would receive.
    pub mint_out: Pubkey,
    /// Amount of the input token to simulate selling (atomic units).
    pub amount_in: u64,
}

// ─── Result types ─────────────────────────────────────────────────────────────

/// Result of [`A2ASwapClient::create_pool`].
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreatePoolResult {
    /// Confirmed transaction signature.
    pub signature: String,
    /// On-chain pool PDA address.
    pub pool: Pubkey,
    /// Pool authority PDA that owns the token vaults.
    pub pool_authority: Pubkey,
    /// Token A vault account (fresh keypair generated by this call).
    pub vault_a: Pubkey,
    /// Token B vault account (fresh keypair generated by this call).
    pub vault_b: Pubkey,
    /// Token A mint.
    pub mint_a: Pubkey,
    /// Token B mint.
    pub mint_b: Pubkey,
    /// LP fee rate that was set (basis points).
    pub fee_rate_bps: u16,
}

/// Result of [`A2ASwapClient::provide_liquidity`].
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProvideResult {
    /// Confirmed transaction signature.
    pub signature: String,
    /// Pool that received the liquidity.
    pub pool: Pubkey,
    /// Agent's position account (created on first deposit, updated thereafter).
    pub position: Pubkey,
    /// Actual token A deposited.
    pub amount_a: u64,
    /// Actual token B deposited (may differ from input if proportionally computed).
    pub amount_b: u64,
}

/// Result of [`A2ASwapClient::convert`].
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SwapResult {
    /// Confirmed transaction signature.
    pub signature: String,
    /// Pool used for the swap.
    pub pool: Pubkey,
    /// Tokens sold.
    pub amount_in: u64,
    /// Pre-flight simulation estimate of tokens received.
    pub estimated_out: u64,
    /// Minimum tokens the on-chain program would accept (slippage guard).
    pub min_amount_out: u64,
    /// `true` = token A → token B; `false` = token B → token A.
    pub a_to_b: bool,
}

/// Full fee and slippage breakdown from [`A2ASwapClient::simulate`].
///
/// All amounts are in atomic units (lamports, μUSDC, …).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SimulateResult {
    /// Pool used for the simulation.
    pub pool: Pubkey,
    /// `true` = token A → token B; `false` = token B → token A.
    pub a_to_b: bool,
    /// Input amount (atomic units).
    pub amount_in: u64,
    /// Protocol fee skimmed from `amount_in` (0.020%, sent to treasury).
    pub protocol_fee: u64,
    /// `amount_in − protocol_fee` — what the pool receives as gross input.
    pub net_pool_input: u64,
    /// LP fee deducted from `net_pool_input` (stays in vault, accrues to LPs).
    pub lp_fee: u64,
    /// `net_pool_input − lp_fee` — the amount that actually moves the AMM curve.
    pub after_fees: u64,
    /// Expected output tokens from the constant-product formula.
    pub estimated_out: u64,
    /// `estimated_out / amount_in` — effective exchange rate (raw units).
    pub effective_rate: f64,
    /// Pure AMM slippage: `after_fees / (reserve_in + after_fees) × 100`.
    /// Does not include fee cost — purely the price-curve effect.
    pub price_impact_pct: f64,
    /// LP fee rate of this pool (basis points).
    pub fee_rate_bps: u16,
    /// Input-side vault reserve (atomic units).
    pub reserve_in: u64,
    /// Output-side vault reserve (atomic units).
    pub reserve_out: u64,
}

/// Pool state snapshot from [`A2ASwapClient::pool_info`].
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PoolInfo {
    /// Pool PDA address.
    pub pool: Pubkey,
    /// Token A mint.
    pub mint_a: Pubkey,
    /// Token B mint.
    pub mint_b: Pubkey,
    /// Token A vault.
    pub vault_a: Pubkey,
    /// Token B vault.
    pub vault_b: Pubkey,
    /// Token A reserve (atomic units).
    pub reserve_a: u64,
    /// Token B reserve (atomic units).
    pub reserve_b: u64,
    /// Total LP shares outstanding.
    pub lp_supply: u64,
    /// Trading fee rate (basis points).
    pub fee_rate_bps: u16,
    /// Spot price: `reserve_b / reserve_a` in raw atomic units.
    /// `0.0` when the pool is empty.
    pub spot_price: f64,
}

/// Single LP position summary from [`A2ASwapClient::my_positions`] /
/// [`A2ASwapClient::my_fees`].
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PositionInfo {
    /// On-chain position PDA address.
    pub address: Pubkey,
    /// Pool this position belongs to.
    pub pool: Pubkey,
    /// Owner of this position.
    pub owner: Pubkey,
    /// LP shares held by this position.
    pub lp_shares: u64,
    /// Fees already accounted for on-chain (from last `claim_fees` / `provide`).
    pub fees_owed_a: u64,
    /// Same as `fees_owed_a` but for token B.
    pub fees_owed_b: u64,
    /// Fees accrued since the last on-chain sync (computed from `fee_growth_global` delta).
    pub pending_fees_a: u64,
    /// Same as `pending_fees_a` but for token B.
    pub pending_fees_b: u64,
    /// `fees_owed_a + pending_fees_a` — total claimable now.
    pub total_fees_a: u64,
    /// `fees_owed_b + pending_fees_b` — total claimable now.
    pub total_fees_b: u64,
    /// Whether this position auto-compounds fees.
    pub auto_compound: bool,
    /// Minimum fee balance to trigger an auto-compound (0 = always).
    pub compound_threshold: u64,
}

/// Aggregated fee summary across all positions, from [`A2ASwapClient::my_fees`].
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FeeSummary {
    /// Per-position fee breakdown.
    pub positions: Vec<PositionInfo>,
    /// Sum of `total_fees_a` across all positions.
    pub total_fees_a: u64,
    /// Sum of `total_fees_b` across all positions.
    pub total_fees_b: u64,
}
